"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[574],{1784:(e,t,n)=>{n.r(t),n.d(t,{adder_cmakelists:()=>p,adder_v:()=>o,assets:()=>c,cmakelists:()=>h,contentTitle:()=>d,default:()=>j,frontMatter:()=>s,main_cpp:()=>u,metadata:()=>l,toc:()=>m});var i=n(4848),a=n(8453),r=n(1432);const s={sidebar_position:3},d="Verilator C++ testbench",l={id:"examples/verilator",title:"Verilator C++ testbench",description:"Description",source:"@site/docs/examples/verilator.mdx",sourceDirName:"examples",slug:"/examples/verilator",permalink:"/SoCMake/docs/examples/verilator",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/examples/verilator.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Hierarchical design",permalink:"/SoCMake/docs/examples/linking_ips"}},c={},o=n(4774).A,h=n(5119).A,p=n(464).A,u=n(9995).A,m=[{value:"Description",id:"description",level:3},{value:"Example",id:"example",level:2},{value:"Directory structure",id:"directory-structure",level:3},{value:"adder/adder.v",id:"adderadderv",level:3},{value:"adder/CMakeLists.txt",id:"addercmakeliststxt",level:3},{value:"main.cpp",id:"maincpp",level:3},{value:"CMakeLists.txt",id:"cmakeliststxt",level:3},{value:"Build graph",id:"build-graph",level:3},{value:"Running the simulation",id:"running-the-simulation",level:2}];function x(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{id:"verilator-c-testbench",children:"Verilator C++ testbench"}),"\n","\n","\n",(0,i.jsx)(t.h3,{id:"description",children:"Description"}),"\n",(0,i.jsx)(t.p,{children:"This example shows how to create a C++ testbench and instantiate a Verilated RTL IP library."}),"\n",(0,i.jsxs)(t.p,{children:["In this case we will have an IP library called ",(0,i.jsx)(t.code,{children:"adder"}),", that is just a simple combinatorial adder with only 1 file ",(0,i.jsx)(t.code,{children:"adder.v"}),".",(0,i.jsx)("br",{}),"\nWe will also have a C++ testbench ",(0,i.jsx)(t.code,{children:"main.cpp"})]}),"\n",(0,i.jsx)(t.h2,{id:"example",children:"Example"}),"\n",(0,i.jsx)(t.h3,{id:"directory-structure",children:"Directory structure"}),"\n",(0,i.jsx)(t.p,{children:"Lets take a look at the directory structure of the example first."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-raw",children:".\n\u251c\u2500\u2500 adder\n\u2502\xa0\xa0 \u251c\u2500\u2500 adder.v\n\u2502\xa0\xa0 \u2514\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 deps\n\u2502\xa0\xa0 \u251c\u2500\u2500 CPM.cmake\n\u2502\xa0\xa0 \u2514\u2500\u2500 deps.cmake\n\u2514\u2500\u2500 main.cpp\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We have a directory ",(0,i.jsx)(t.code,{children:"adder/"})," that contains the ",(0,i.jsx)(t.code,{children:"adder"})," IP block, it as its own ",(0,i.jsx)(t.code,{children:"CMakeLists.txt"})," to make it easier to reuse in a larger project."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["For a design this simple it is not really necessary to have a separate ",(0,i.jsx)(t.code,{children:"CMakeLists.txt"}),", but it is a good practice anyways."]})}),"\n",(0,i.jsx)(t.h3,{id:"adderadderv",children:"adder/adder.v"}),"\n",(0,i.jsx)(t.p,{children:"Adder verilog file is just a simple two 8bit inputs, and a 9bit output module."}),"\n",(0,i.jsx)(r.A,{language:"verilog",title:"adder/adder.v",showLineNumbers:!0,children:o}),"\n",(0,i.jsx)(t.h3,{id:"addercmakeliststxt",children:"adder/CMakeLists.txt"}),"\n",(0,i.jsxs)(t.p,{children:["There is nothing new in this file from previous examples.\nWe are making a library under the full name ",(0,i.jsx)(t.code,{children:"cern::ip::adder::0.0.1"}),"."]}),"\n",(0,i.jsx)(r.A,{language:"cmake",title:"adder/CMakeLists.txt",showLineNumbers:!0,children:p}),"\n",(0,i.jsx)(t.h3,{id:"maincpp",children:"main.cpp"}),"\n",(0,i.jsx)(t.p,{children:"This is a standard C++ testbench using a Verilated model. Refer to Verilator documentation for more information."}),"\n",(0,i.jsx)(r.A,{language:"cpp",title:"main.cpp",showLineNumbers:!0,children:u}),"\n",(0,i.jsx)(t.h3,{id:"cmakeliststxt",children:"CMakeLists.txt"}),"\n",(0,i.jsxs)(t.p,{children:["And finally we need a top ",(0,i.jsx)(t.code,{children:"CMakeLists.txt"})," that will assemble the full design and create simulation targets."]}),"\n",(0,i.jsx)(r.A,{language:"cmake",title:"CMakeLists.txt",showLineNumbers:!0,children:h}),"\n",(0,i.jsxs)(t.p,{children:["We can add the ",(0,i.jsx)(t.code,{children:"adder"})," IP as a subdirectory with ",(0,i.jsx)(t.a,{href:"https://cmake.org/cmake/help/latest/command/add_subdirectory.html",children:(0,i.jsx)(t.code,{children:"add_subdirectory()"})})," CMake function."]}),"\n",(0,i.jsxs)(t.p,{children:["Then we are creating the target to Verilate the IP.\nExecuting the ",(0,i.jsx)(t.code,{children:"cern__ip__adder__0.0.1_verilate"})," target will compile a ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Static_library",children:"static library"})," of the IP block.",(0,i.jsx)("br",{}),"\nThis time we are not asking Verilator to create a ",(0,i.jsx)(t.code,{children:"main.cpp"})," file as we will write it ourselves.",(0,i.jsx)("br",{}),"\nWe are also passing ",(0,i.jsx)(t.code,{children:"TRACE"})," argument to ",(0,i.jsx)(t.code,{children:"verilate()"}),", indicating that we want to enable ",(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Value_change_dump",children:(0,i.jsx)(t.code,{children:"VCD"})})," generation in Verilated model."]}),"\n",(0,i.jsxs)(t.p,{children:["After that we create an ",(0,i.jsx)(t.code,{children:"executable"})," with ",(0,i.jsx)(t.a,{href:"https://cmake.org/cmake/help/latest/command/add_executable.html",children:(0,i.jsx)(t.code,{children:"add_executable()"})})," CMake function. The first argument is the name of the compiled executable, and then we pass a list of sources, in this case only ",(0,i.jsx)(t.code,{children:"main.cpp"})]}),"\n",(0,i.jsxs)(t.p,{children:["Finally we use ",(0,i.jsx)(t.a,{href:"https://cmake.org/cmake/help/latest/command/target_link_libraries.html",children:(0,i.jsx)(t.code,{children:"target_link_libraries()"})}),", to link the Verilated static library into our testbench executable, and also add the include paths for headers of the Verilated model, and Verilator headers."]}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsxs)(t.p,{children:["Notice in the line 11, we are linking to the static library created with Verilator.\nIt is a bit annoying to have to change the version number manually, in order to avoid it it is a better idea to set a variable in ",(0,i.jsx)(t.code,{children:"adder/CMakeLists.txt"})," that will hold the full name of the IP."]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cmake",metastring:'title="adder/CMakeLists.txt"',children:"...\nif(NOT PROJECT_IS_TOP_LEVEL)    # Avoid warning if project is top level\n    set(ADDER_LIB_NAME ${IP} PARENT_SCOPE)\nendif()\n"})}),(0,i.jsxs)(t.p,{children:["And then in ",(0,i.jsx)(t.code,{children:"CMakeLists.txt"}),":"]}),(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cmake",metastring:'title="CMakeLists.txt"',children:"...\ntarget_link_libraries(testbench ${ADDER_LIB_NAME}__vlt)\n"})})]}),"\n",(0,i.jsx)(t.h3,{id:"build-graph",children:"Build graph"}),"\n",(0,i.jsxs)(t.p,{children:["Take a look at the build graph for this example.\nWe can see that the ",(0,i.jsx)(t.code,{children:"testbench"})," executable depends on Verilated models and Verilator targets.\nExecuting the ",(0,i.jsx)(t.code,{children:"testbench"})," targets, the dependencies will be built first."]}),"\n",(0,i.jsx)("div",{style:{display:"flex",justifyContent:"center"},children:(0,i.jsx)("img",{src:n(984).A,alt:"graph"})}),"\n",(0,i.jsx)("div",{style:{display:"flex",justifyContent:"center"},children:(0,i.jsx)("img",{src:n(917).A,alt:"graph",width:"80%"})}),"\n",(0,i.jsx)(t.h2,{id:"running-the-simulation",children:"Running the simulation"}),"\n",(0,i.jsx)(t.p,{children:"Simulation can be run the same way as always:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-bash",children:"mkdir build\ncd build\ncmake ../                  # Configure project\nmake testbench -j$(nproc)  # Build testbench\n./testbench                # Execute testbench\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["Use ",(0,i.jsx)(t.a,{href:"https://github.com/scop/bash-completion",children:"bash-completion"})," to autocomplete ",(0,i.jsx)(t.code,{children:"make"})," target names.\nAfter typing ",(0,i.jsx)(t.code,{children:"make "})," press ",(0,i.jsx)(t.code,{children:"Tab \u21b9"})," twice."]})})]})}function j(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(x,{...e})}):x(e)}},5119:(e,t,n)=>{n.d(t,{A:()=>i});const i='cmake_minimum_required(VERSION 3.25)\nproject(example CXX C)\n\ninclude("../../SoCMakeConfig.cmake")\n\nadd_subdirectory(adder)\n\nverilator_build(VERSION 5.012 EXACT_VERSION)\n\nverilator(adder TRACE)\n\nadd_executable(testbench main.cpp)\n\ntarget_link_libraries(testbench adder)\n\nhelp()\n'},464:(e,t,n)=>{n.d(t,{A:()=>i});const i='cmake_minimum_required(VERSION 3.25)\nproject(adder NONE)\n\nadd_ip(adder\n    DESCRIPTION "Just a simple adder"\n    )\n\nip_sources(${IP} VERILOG\n    adder.v\n    )\n'},4774:(e,t,n)=>{n.d(t,{A:()=>i});const i="module adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] o\n);\n\n    assign o = a + b;\n endmodule\n"},9995:(e,t,n)=>{n.d(t,{A:()=>i});const i='#include <cstdlib>\n#include <iostream>\n#include <verilated.h>\n#include <verilated_vcd_c.h>\n#include "Vadder.h"\n\nint main (int argc, char *argv[]) {\n    Verilated::traceEverOn(true);\n\n    Vadder dut;\n\n    VerilatedVcdC* m_trace;\n    m_trace = new VerilatedVcdC;\n    dut.trace(m_trace, 99);\n    m_trace->open("trace.vcd");\n\n    dut.eval();\n\n    for(int i =0; i<30; i++){\n        dut.a = i;\n        dut.b = i+10;\n\n        dut.eval();\n        m_trace->dump(10 * i + 10/2);\n\n        std::cout << (uint32_t)dut.a <<\n            " + " << (uint32_t)dut.b <<\n            " = " << (uint32_t)dut.o << "\\n";\n\n        if(dut.o != 2*i+10){\n            std::cerr << "Mismatch\\n    DUT: " << dut.o << "\\n    REF: " << 2*i+10 << "\\n";\n            std::exit(EXIT_FAILURE);\n        }\n    }\n\n    m_trace->close();\n    \n    return 0;\n}\n'},984:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/graph-70f9ee9e0efc08a226d3423c36a07b75.png"},917:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/legend-35932698e07f13c8a28e80293d6013d2.png"}}]);