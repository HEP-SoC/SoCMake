include_guard(GLOBAL)

# [[[
# This function runs the Icarus Verilog (iverilog) tool on a specified IP library.
#
# The function is a wrapper around the iverilog tool and generates necessary scripts
# and configurations to compile the specified IP library.
#
# :param IP_LIB: Name of the IP library to run iverilog on.
# :type IP_LIB: string
#
# **Keyword Arguments**
#
# :keyword OUTDIR: Output directory for iverilog results. Defaults to BINARY_DIR.
# :type OUTDIR: string
# :keyword EXECUTABLE: Name of the output executable generated by iverilog. Defaults to IP_LIB_iv.
# :type EXECUTABLE: string
# ]]]
function(cocotb IP_LIB)
    # Parse the function arguments
    # cmake_parse_arguments(ARG "" "VIRTUAL_ENV;TOP_MODULE;OUTDIR;EXECUTABLE;IVERILOG_CLI_FLAGS;TIMEUNIT;TIMEPRECISION;TOPLEVEL_LANG;TESTCASE;COCOTB_TEST" "PATH_MODULE;SIM_ARGS;PLUSARGS" ${ARGN})
    cmake_parse_arguments(ARG "NO_RUN_TARGET;GUI" "OUTDIR;RUN_TARGET_NAME;TOP_MODULE;COCOTB_MODULE;COCOTB_TESTCASE;TOP_MODULE_LANG;SIM" "PYTHONPATH;COMPILE_ARGS;COCOTB_ARGS;RUN_ARGS" ${ARGN})
    # Check for any unrecognized arguments
    if(ARG_UNPARSED_ARGUMENTS)
        message(FATAL_ERROR "${CMAKE_CURRENT_FUNCTION} passed unrecognized argument " "${ARG_UNPARSED_ARGUMENTS}")
    endif()

    # Include the hardware IP management cmake functions
    include("${CMAKE_CURRENT_FUNCTION_LIST_DIR}/../../hwip.cmake")

    # Assume the IP library is the latest one provided if full name is not given
    alias_dereference(IP_LIB ${IP_LIB})
    get_target_property(BINARY_DIR ${IP_LIB} BINARY_DIR)

    # Get the IP RTL sources
    get_ip_sources(SOURCES ${IP_LIB} SYSTEMVERILOG VERILOG)
    # Get the sim_only sources only if we are not running a technology-independent flow
    if(NOT TECH_FLOW)
        get_ip_sources(SIM_SOURCES ${IP_LIB} SYSTEMVERILOG_SIM VERILOG_SIM)
    endif()
    list(PREPEND SOURCES ${SIM_SOURCES})

    # Get IP include directories
    get_ip_include_directories(INC_DIRS ${IP_LIB} SYSTEMVERILOG VERILOG)

    # Get IP compile definitions
    get_ip_compile_definitions(COMP_DEFS ${IP_LIB} SYSTEMVERILOG VERILOG)
    # Prepare compile definitions arguments for targeted simulator
    list(APPEND _SIMULATOR_DEFINE_DASH icarus verilator)
    list(APPEND _SIMULATOR_DEFINE_PLUS xcelium questa modelsim vcs)

    # Add COCOTB_SIM define for all simulators
    list(APPEND COMP_DEFS COCOTB_SIM)

    if("${ARG_SIM}" IN_LIST _SIMULATOR_DEFINE_DASH)
        set(_define_prefix "-D")
    elseif("${ARG_SIM}" IN_LIST _SIMULATOR_DEFINE_PLUS)
        set(_define_prefix "+define+")
    else()
        message(FATAL_ERROR "Unsupported simulator: ${ARG_SIM}\nSupported simulators are: icarus, verilator, xcelium, modelsim, vcs.")
    endif()
    foreach(def ${COMP_DEFS})
        list(APPEND CMP_DEFS_ARG ${_define_prefix}${def})
    endforeach()

    if(ARG_COMPILE_ARGS OR CMP_DEFS_ARG)
        set(COMPILE_ARGS ${ARG_COMPILE_ARGS} ${CMP_DEFS_ARG})
    endif()

    # Get IP include directories
    get_ip_include_directories(INC_DIRS ${IP_LIB} SYSTEMVERILOG VERILOG)

    # Generator expression for OUTDIR = defined(ARG_OUTDIR) ? ARG_OUTDIR : BINARY_DIR
    set(OUTDIR $<IF:$<BOOL:${ARG_OUTDIR}>,${ARG_OUTDIR},${BINARY_DIR}>)

    if(NOT ARG_TOP_MODULE)
        get_target_property(ARG_TOP_MODULE ${IP_LIB} IP_NAME)
    endif()

    if(ARG_PYTHONPATH)
        # Column separated paths to python files/modules are needed
        string(REPLACE ";" ":" PYTHONPATH "${ARG_PYTHONPATH}")
    endif()

    if(NOT ARG_COCOTB_MODULE)
        message(FATAL_ERROR "No cocotb module provided. Provide the function argument COCOTB_MODULE.")
    endif()

    # Default parameters based on cocotb Makefile.inc
    set(COCOTB_RESULTS_FILE ${OUTDIR}/results.xml)

    # Get cocotb makefiles directory
    find_program(COCOTB_CONFIG_EXECUTABLE cocotb-config)
    execute_process(
        OUTPUT_VARIABLE COCOTB_MAKEFILES_DIR
        ERROR_VARIABLE ERROR_MSG
        COMMAND ${COCOTB_CONFIG_EXECUTABLE} --makefiles
    )

    set(run_sim_cmd
        PYTHONPATH=${PYTHONPATH}
        TOPLEVEL=${ARG_TOP_MODULE}
        MODULE=${ARG_COCOTB_MODULE}
        SIM_BUILD=${OUTDIR}
        $<$<BOOL:${ARG_GUI}>:GUI=1>
        $<$<BOOL:${ARG_COCOTB_TESTCASE}>:TESTCASE=${ARG_COCOTB_MODULE}_test_${ARG_COCOTB_TESTCASE}>
        $<$<BOOL:${ARG_TOP_MODULE_LANG}>:TOPLEVEL_LANG=${ARG_TOP_MODULE_LANG}>
        SIM=${ARG_SIM}
        COMPILE_ARGS="${COMPILE_ARGS}"
        $<$<BOOL:${ARG_RUN_ARGS}>:SIM_ARGS=${ARG_RUN_ARGS}>
        $<$<BOOL:${ARG_COCOTB_ARGS}>:${ARG_COCOTB_ARGS}>
        VERILOG_SOURCES="${SOURCES}"
        VERILOG_INCLUDE_DIRS="${INC_DIRS}"
        COCOTB_RESULTS_FILE=${COCOTB_RESULTS_FILE}
        make -f Makefile.sim sim -C ${COCOTB_MAKEFILES_DIR}
    )

    # Add a custom command to run cocotb
    add_custom_command(
        OUTPUT ${COCOTB_RESULTS_FILE}
        COMMAND ${CMAKE_COMMAND} -E make_directory ${OUTDIR}
        COMMAND ${run_sim_cmd}
        DEPENDS ${IP_LIB}
        COMMENT "Running cocotb simulation on ${IP_LIB}"
    )

    if(NOT ARG_NO_RUN_TARGET)
        # Use TESTCASE for target name if it exists to have a unique name
        if(ARG_RUN_TARGET_NAME)
            set(CUSTOM_TARGET_NAME ${ARG_RUN_TARGET_NAME})
        else()
            if(ARG_COCOTB_TESTCASE)
                set(TESTCASE _test_${ARG_COCOTB_TESTCASE})
            endif()
            set(CUSTOM_TARGET_NAME run_${IP_LIB}_${CMAKE_CURRENT_FUNCTION}_${ARG_COCOTB_MODULE}${TESTCASE})
        endif()

        # Add a custom target that depends on the executable and stamp file
        add_custom_target(
            ${CUSTOM_TARGET_NAME}
            DEPENDS ${COCOTB_RESULTS_FILE}
        )
    endif()

    # Set the command as a property to be easily found by add_test()
    # string(TOUPPER ${ARG_COCOTB_MODULE}${TESTCASE} COCOTB_RUN_PROP)
    # set_target_properties(${IP_LIB} PROPERTIES COCOTB_${COCOTB_RUN_PROP} "${run_sim_cmd}")
    # set_target_properties(${IP_LIB} PROPERTIES COCOTB_IVERILOG_${COCOTB_TEST_PROP}_ENV "${COCOTB_ENV_VARS}")

    set(SIM_RUN_CMD ${run_sim_cmd} PARENT_SCOPE)

endfunction()

