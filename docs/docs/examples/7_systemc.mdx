---
sidebar_position: 7
---

# SystemC
:::info
The source code for this example can be found in [examples/systemc](https://github.com/HEP-SoC/SoCMake/tree/master/examples/systemc)
:::

import CodeBlock from '@theme/CodeBlock';
export const cmakelists = require('!!raw-loader!../../../examples/systemc/CMakeLists.txt')?.default;
export const testbench = require('!!raw-loader!../../../examples/systemc/sc_main.cpp')?.default;

### Description

This example shows how to do simulation using SystemC with SoCMake.

In this case, we will have a main SystemC file `sc_main.cpp` that will instantiate a module and a function and use both in a test.

## Example

### Directory structure

Lets take a look at the directory structure of the example first.

```raw
.
├── CMakeLists.txt
└── sc_main.cpp
```

### sc_main.cpp

This is a standard SystemC file. It contains a C++ function to print a message and also a SystemC module, that will also print a message.
The main function will then try the 2 approaches by calling the function and instantiating the SystemC module.

<CodeBlock language="cpp" title="sc_main.cpp" showLineNumbers>{testbench}</CodeBlock>


### CMakeLists.txt

And finally we need a top `CMakeLists.txt` that will assemble the full project and create simulation targets.

<CodeBlock language="cmake" title="CMakeLists.txt" showLineNumbers>{cmakelists}</CodeBlock>

As usual, we add the executable to our project and we link the SystemC library using the `target_link_libraries` function.

It can be useful to create a custom target, to directly build and execute the target instead of manually executing it.

## Running the simulation

Simulation can be run the same way as always:

```bash
mkdir build
cd build
cmake ../                           # Configure project
make run_systemc_example -j$(nproc) # Build and run testbench
```
:::info
It's possible to use the cmake argument `-DFETCHCONTENT_BASE_DIR=...` if you want to build systemc in a specific location.
:::